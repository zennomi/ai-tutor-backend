---
description: Project-specific overview and non-obvious rules
globs: **/*
---

## Essentials

- NestJS + TypeScript, modular monolith.
- PostgreSQL with TypeORM; entities extend `AbstractEntity`.
- Package manager: **pnpm** (avoid npm/yarn).
- Path aliases: `@/api/*`, `@/common/*`, `@/config/*`, `@/database/*`, etc.
- Status/type columns are **int** backed by numeric enums (e.g., `UserStatus = 1,2,3`).

## Commands

- Install deps: `pnpm i`.
- Type-check/build: `pnpm build` (run after adding packages).
- Migrations: `pnpm migration:generate src/database/migrations/name-of-migration`; apply with `pnpm migration:up`; revert with `pnpm migration:down`.
- Seeding: `pnpm seed:create`, `pnpm seed:run`.
- After changing code (e.g., .ts files), run `pnpm build` (typecheck) and `pnpm lint`.

## Architecture & structure

- Feature modules live under `src/api/*` (controllers, services, DTOs, entities).
- Shared/global pieces: `src/common`, `src/shared`, `src/constants`, `src/utils`.
- Generated code belongs in `src/generated/` — do not edit manually.
- Keep business logic in services; controllers stay thin; DTOs handle validation/transform (class-validator/transformer).

## Code style deviations to remember

- Import order: polyfills → node builtins → externals → internal alias → parent → sibling; alphabetize within groups; use `import type` for type-only imports.
- Two-space indent, single quotes, semicolons (ESLint/Prettier enforced).
- Prefer `type` for unions/intersections; `interface` for extends/implements.
- Use path aliases instead of deep relative imports.

## Repository etiquette

- Work on feature branches; keep `main` clean.
- Conventional Commits required (e.g., `feat(scope): subject`).
- Avoid force pushes; keep commits scoped and reviewable.

## Environment & setup quirks

- Copy `.env` from `.env.example`; use `@nestjs/config` with typed configs.
- Ensure Postgres is running before migrations/tests.
- Run migrations after entity/schema changes; rerun seeds if data fixtures are needed.

## Common gotchas

- Use numeric enums for DB statuses (do not switch to strings).
- Keep `src/generated/` untouched; regenerate instead of editing.
- Validate all inputs on DTOs; rely on guards for authZ/authN, not controller logic.
- Prefer pagination DTOs in `src/common/dto/`; avoid ad-hoc pagination shapes.
- When defining DTO fields, use the shared decorators in `@/decorators/field.decorators` where possible.
